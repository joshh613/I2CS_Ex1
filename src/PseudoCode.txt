//FUNCTION 1
double[] PolynomFromPoints(double[] x, y):

if (xx==null || yy==null):
    return null

int lx=xx.length, ly=yy.length

if (lx!=ly):
    return null

if (lx==2):
    double b = (y[1]-y[0]) / (x[1]-x[0])
    double a = y[0] - b*x[0]

    return new double[]{a, b}

if (lx==3):
    double denom = (x[0] - x[1])*(x[0] - x[2])*(x[1] - x[2])
    double a = (x[2] * (y[1] - y[0]) + x[1] * (y[0] - y[2]) + x[0] * (y[2] - y[1])) / denom
    double b = (x[2] * x[2] * (y[0] - y[1]) + x[1] * x[1] * (y[2] - y[0]) + x[0] * x[0] * (y[1] - y[2])) / denom
    double c = (x[1] * x[2] * (x[1] - x[2]) * y[0] + x[2] * x[0] * (x[2] - x[0]) * y[1] + x[0] * x[1] * (x[0] - x[1]) * y[2]) / denom

    return new double[]{a, b, c}

return null


//FUNCTION 2
boolean equal(double[] p1, p2):

if (p1==null || p2==null):
    return p1==null && p2==null //if they're both null, they're 'equal'

int n = Math.max(p1.length, p2.length)

for (int i=0, i<n; i++):
    double y1 = f(p1, i)
    double y2 = f(p2, i)

    if (Math.abs(y1-y2) > EPS):
        return false

return true


//FUNCTION 3
String poly(double[] poly):

if (poly==null || poly.length==0):
    return "0"

String ans = ""

int n = poly.length
if (n>2):
    for (int i=n-2; i>1; i--):
        coef = poly[i]
        if (coef>0):
            ans += "+" + coef + "x^" + i + " "
        elif (coef<0):
            ans += coef + "x^" + i + " "

if (n>1):
    coef = poly[1]
    if (coef>0):
        ans += "+" + coef + "x" + " "
    elif (coef<0):
        ans += coef + "x" + " "

coef = poly[0]
if (coef>0):
    ans += "+" + coef
elif (coef<0):
    ans += coef

if (ans==""):
    ans = "0"

return ans


//FUNCTION 4
double sameValue(double[] p1, p2, double x1, x2, eps):

if (p2==null):
    return -1

for (int i=0; i<p2.length; i++):
    p2[i] *= -1

p1 = add(p1, p2)

return root_rec(p1, x1, x2, eps)


//FUNCTION 5
double length(double[] p, double x1, x2, int numberOfSegments):

double ans = 0

double width = (x2 - x1) / numberOfSegments
double widthSquared = width*width

for (int i=0; i<=numberOfSegments; i++):
    //using Pythagoras' theorem
    double startX = x1 + width*i
    double endX = start + width
    double height = f(p, endX) - f(p, startX)

    ans += Math.sqrt(widthSquared + height*height)

return ans


//FUNCTION 6
double[] getPolynomFromString(String p):

String[] coef = p.split(" ")
double[] ans = new double[coef.length]

for (int i=0; i<coef.length; i++):
    if (coef[i].charAt(0)=="+"):
        ans[ans.length-1-i] = (double) originalString.substring(1)
    else:
        ans[ans.length-1-i] -= (double) originalString.substring(1)

return ans


//FUNCTION 6
double[] add(double[] p1, p2):

if (p1==null || p2==null):
    return null

if (p1.length > p2.length):
    return simpleAdd(p1, p2)

return simpleAdd(p2, p1)


//FUNCTION 6A
double[] simpleAdd(double[] p1, p2):

for (int i=0; i<p2.length; i++):
    p1[i] += p2[i]

return p1


//FUNCTION 7
double[] mul(double[] p1, p2):

if (p1==null || p2==null || p1.length==0 || p2.length==0):
    return null

double[] ans = new double[p1.length*p2.length]

for (int i=0; i<p1.length; i++):
    for (int j=0; j<p2.length; j++):
        ans[i+j] += p1[i]*p2[i]

return ans


//FUNCTION 8
double[] derivative(double[] po):

if (po==null || po.length==0):
    return null

if (po.length==1):
    return ZERO

double[] ans = new double[po.length-1]

for (int i=1; i<po.length; i++):
    ans[i] = po[i]*i

return ans