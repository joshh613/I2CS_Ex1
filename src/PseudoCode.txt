//FUNCTION 1
double[] PolynomFromPoints(double[] xx, yy):

if (xx==null || yy==null):
    return null

int lx=xx.length, ly=yy.length

if (lx!=ly):
    return null

if (lx==2):
    double b = (y[1]-y[0]) / (xx[1]-xx[0]) //TODO: check we aren't diving by zero
    double a = y[0] - b*xx[0]

    return new double[]{a, b}

if (lx==3):
    double denom = (xx[0] - xx[1])*(xx[0] - xx[2])*(xx[1] - xx[2])
    double a = (xx[1] * xx[2] * (xx[1] - xx[2]) * y[0] + xx[2] * xx[0] * (xx[2] - xx[0]) * y[1] + xx[0] * xx[1] * (xx[0] - xx[1]) * y[2]) / denom
    double b = (xx[2] * xx[2] * (y[0] - y[1]) + xx[1] * xx[1] * (y[2] - y[0]) + xx[0] * xx[0] * (y[1] - y[2])) / denom
    double c = (xx[2] * (y[1] - y[0]) + xx[1] * (y[0] - y[2]) + xx[0] * (y[2] - y[1])) / denom

    return new double[]{a, b, c}

return null


//FUNCTION 2
boolean equals(double[] p1, p2):

if (p1==null || p2==null):
    return p1==null && p2==null //if they're both null, they're 'equal'

int n = Math.max(p1.length, p2.length)

for (int i=0, i<n; i++):
    double y1 = f(p1, i)
    double y2 = f(p2, i)

    if (Math.abs(y1-y2) > EPS):
        return false

return true


//FUNCTION 3
String poly(double[] poly):

if (poly==null || poly.length==0):
    return "0"

String[] parts = new String[poly.length]
for (int i=0; i<poly.length; i++):
    double coef = poly[i]
    if (coef==1):
        parts[i] = " +" //so we have +x, instead of +1.0x
    elif (coef>0):
        parts[i] = " +" + coef
    elif (coef==-1):
            parts[i] = " -" //so we have -x, instead of +1.0x
    elif (coef<0):
        parts[i] = " " + coef
    else:
        parts[i] = ""

if (parts.length>1 && parts[1]!=""):
    parts[1] += "x"

for (int i=2; i<parts.length; i++):
    String coef = parts[i]
    if (coef!=""):
        parts[i] += "x^" + i

String ans = ""
for (int i=parts.length-1; i>=0; i--):
    ans += parts[i]

if (ans==""):
    return "0"

if (ans.charAt(1) == "+"):
    return ans.substring(2) //to remove the leading space and plus

return ans.substring(1)


//FUNCTION 4
double sameValue(double[] p1, p2, double x1, x2, eps):

if (p1==null || p2==null):
    return -1

double[] p = add(p1, neg(p2))

return root_rec(p, x1, x2, eps)


//FUNCTION 5
double length(double[] p, double x1, x2, int numberOfSegments):

double ans = 0

double width = (x2 - x1) / numberOfSegments
double widthSquared = width*width

for (int i=0; i<numberOfSegments; i++):
    //using Pythagoras' theorem
    double startX = x1 + width*i
    double endX = startX + width
    double height = f(p, endX) - f(p, startX)

    ans += Math.sqrt(widthSquared + height*height)

return ans


//FUNCTION 6
double area(double[] p1, p2, double x1, x2, int numberOfTrapezoid):

//the area is (a+b)*h/2

double[] p = add(p1, neg(p2))

double width = (x2-x1)/numberOfTrapezoid
double x = x1
double a = f(p, x)

double ans = 0
for (int i=0; i<numberOfTrapezoid; i++):
    x += width
    double b = f(p, x)
    double temp = (a+b)*width/2
    ans += Math.abs(temp) //we don't want the signed area

    a = b

return ans


//FUNCTION 7
double[] getPolynomFromString(String p): //assumes spaces in between expressions

String[] parts = p.split(" ")
for (int i=0; i<parts.length; i++):
    parts[i] = parts[i].split("^")

int highestPower = 0
for (int i=0; i<parts.length; i++):
    String part = parts[i]
    if (part.length>0): //has an explicit exponent
        highestPower = Math.max(highestPower, part[1])
    else:
        if (part.substring(part-1)=="x"):
            highestPower = Math.max(highestPower, 1)

double[] ans = new double[highestPower+1]
for (int i=0; i<parts.length; i++):
    String part = parts[i]
    int power = 0

    if (part.length>0): //has an explicit exponent
        power = part[1]
    else:
        if (part.substring(part-1)=="x"):
            power = 1

    ans[power] = parts[0]

return ans


//FUNCTION 8
double[] add(double[] p1, p2):

if (p1==null || p2==null):
    return null

double[] ans = new double[Math.max(p1.length, p2.length)]
for (int i=0; i<p1.length; i++):
    ans[i] = p1[i]
for (int i=0; i<p2.length; i++):
    ans[i] += p2[i]

return ans


//FUNCTION 9
double[] mul(double[] p1, p2):

if (p1==null || p2==null || p1.length==0 || p2.length==0):
    return null

double[] ans = new double[p1.length+p2.length-1]

for (int i=0; i<p1.length; i++):
    for (int j=0; j<p2.length; j++):
        ans[i+j] += p1[i]*p2[j]

return ans


//FUNCTION 10
double[] derivative(double[] po):

if (po==null || po.length==0):
    return null

if (po.length==1):
    return ZERO

double[] ans = new double[po.length-1]

for (int i=1; i<po.length; i++):
    ans[i-1] = po[i]*i

return ans


//FUNCTION 11
double[] neg(double[] p):

if (p==null || p.length==0):
    return null

double[] ans = new double[p.length]
for (int i=0; i<p.length; i++):
    ans[i] = -p[i]

return ans